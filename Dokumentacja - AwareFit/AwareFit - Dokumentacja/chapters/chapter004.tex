\chapter{Logika operacyjna i funkcjonalność bazy danych}
\label{cha:LOiFBD}

Struktura bazy danych została zaprojektowana tak, aby wspierała kluczowe funkcje aplikacji AwareFit. Funkcjonalność opiera się na dwóch aspektach: standardowej obsłudze danych poprzez mechanizmy CRUD oraz zaawansowanej logice algorytmicznej, która pozwala na przekształcenie surowych wpisów treningowych w użyteczne informacje analityczne dla użytkownika.

\section{Założenia i wymagania dla mechanizmów CRUD}
Mechanizm CRUD (ang. Create, Read, Update, Delete) stanowi fundament interakcji użytkownika z systemem. W ramach aplikacji AwareFit zdefiniowano, w schemacie \textit{crud} zaimplementowany zestaw funkcji i procedur. Poniżej przedstawiono podział na komponenty CRUD.

\subsection*{Zarządzanie tożsamością i dostępem (Komponent: users)}
Komponent ten dotyczny zarządzeniem kontami użytkowników, zaimplementowany w procedurach schematu \textit{crud}.

\begin{itemize}
    \item \textbf{Operacja Create (Rejestracja):} Wykorzystywana jest procedura \texttt{insert\_user}, która przyjmuje komplet danych: login, hasło, email oraz dane personalne. Zapewnia ona poprawność wpisu w tabeli głównej \textit{public.users}.
    \item \textbf{Operacja Read (Logowanie i Profil):} Funkcja \texttt{get\_all\_users} pozwala na weryfikację uprawnień i pobieranie danych użytkowników. 
    \item \textbf{Operacja Update i Delete:} Zaimplementowano procedury \texttt{update\_user} oraz \texttt{delete\_user}. Warto zaznaczyć, że choć są one gotowe w warstwie bazy danych, aktualna wersja interfejsu graficznego (GUI) nie wykorzystuje ich bezpośrednio, co stanowi przygotowanie pod przyszłą rozbudowę modułu administracyjnego.
\end{itemize}

\newpage
\subsection*{Rejestracja i obsługa sesji treningowych (Komponent: workouts)}
Jest to najbardziej rozbudowany fragment schematu \textit{crud}, obsługujący wielopoziomową strukturę jednostki treningowej.

\begin{itemize}
    \item \textbf{Struktura hierarchiczna:} Proces zapisu treningu jest atomowy i sekwencyjny. Najpierw wywoływana jest procedura \texttt{insert\_workout}, a następnie dla każdego wybranego ćwiczenia \texttt{insert\_workout\_exercise}. Detale wykonania (ciężar, powtórzenia) są zapisywane przez \texttt{insert\_workout\_set}.
    \item \textbf{Zarządzanie zmianami i perspektywy rozwoju:} Procedury \texttt{update\_workout\_set} oraz \texttt{update\_workout\_exercise} zostały zaprojektowane i wdrożone w warstwie bazy danych jako fundament pod przyszłą rozbudowę funkcjonalności systemu. W obecnej iteracji aplikacji, interfejs użytkownika (GUI) nie udostępnia możliwości edycji treningów historycznych, co jest podyktowane dbałością o spójność danych i rzetelność generowanych statystyk. Niemniej jednak, pełna implementacja tych procedur w schemacie \textit{crud} umożliwia ich natychmiastowe wykorzystanie w przyszłości bez konieczności modyfikacji logiki serwera bazy danych.
\end{itemize}


\subsection*{Monitoring parametrów biometrycznych (Komponent: body\_measurements)}

Komponent ten dedykowany jest gromadzeniu i analizie danych o stanie fizycznym użytkownika. Logika bazodanowa została zaprojektowana tak, aby wspierać rzetelne śledzenie progresji w czasie.

\begin{itemize}
    \item \textbf{Rejestracja pomiarów:} 
    Główną operacją w interfejsie użytkownika jest \textit{Create}, realizowana przez zestaw procedur \texttt{insert\_body\_measurement}. Użytkownik ma możliwość regularnego dodawania nowych rekordów zawierających wagę oraz obwody poszczególnych partii ciała.
    
    \item \textbf{Niezmienność danych historycznych:} 
    Przyjęto założenie projektowe, według którego raz wprowadzone dane biometryczne nie podlegają edycji z poziomu interfejsu graficznego (GUI). Ma to na celu zachowanie autentyczności historii pomiarów i uniemożliwienie manipulacji danymi archiwalnymi. 
    
    \item \textbf{Zaimplementowany mechanizm Update:} 
    Pomimo ograniczeń w interfejsie, w schemacie \textit{crud} w pełni zaimplementowano procedurę \texttt{update\_body\_measurement}. Pozwala to na ewentualne przyszłe wdrożenie funkcji korekty błędnych wpisów przez użytkownika.
    
    \item \textbf{Wyświetlanie i prezentacja danych:} 
    Za warstwę \textit{Read} odpowiada funkcja \texttt{get\_all\_body\_measurements} oraz dedykowane zapytania filtrujące, które zasilają interfejs graficzny. Mechanizm ten pozwala na dynamiczne prezentowanie parametrów w formie zestawień tabelarycznych oraz stanowi źródło danych dla poszczególnych funkcji prezentujących informacje na temat ciała.
\end{itemize}

\newpage
\subsection*{Zarządzanie strukturą słownikową (Komponent: exercises \& muscle\_groups)}

Tabele słownikowe stanowią bazę wiedzy systemu, definiując dostępne ćwiczenia oraz ich przynależność do grup mięśniowych. 

\begin{itemize}
    \item \textbf{Dostęp użytkownika:} 
    Z poziomu interfejsu standardowego użytkownika, dostęp do danych słownikowych jest ograniczony wyłącznie do operacji \textit{Read}. Wykorzystywane są do tego funkcje \texttt{get\_all\_exercises} oraz \texttt{get\_all\_muscle\_groups}, które zasilają listy wyboru podczas kreowania nowej sesji treningowej.
    
    \item \textbf{Perspektywa administracyjna:} 
    Mimo braku odpowiednich modułów w bieżącym GUI, w schemacie \textit{crud} zaimplementowano pełen zestaw procedur zarządczych: \texttt{insert\_exercise}, \texttt{update\_exercise}, \texttt{delete\_exercise} (oraz ich odpowiedniki dla grup mięśniowych). 
    
    \item \textbf{Założenia projektowe:} 
    Istnienie tych mechanizmów w warstwie bazy danych zostało przewidziane jako fundament pod dedykowany "Panel Administratora". Pozwoli on w przyszłości na dynamiczne rozbudowywanie bazy ćwiczeń, czy edycję opisów bez konieczności bezpośredniej ingerencji programisty w strukturę bazy danych.
\end{itemize}


\newpage
\section{Implementacja mechanizmów CRUD na przykładzie komponentu użytkowników}

W celu zapewnienia integralności danych oraz odciążenia warstwy logicznej aplikacji (PHP), kluczowe reguły zostały zaimplementowane bezpośrednio w procedurach składowanych schematu \textit{crud}.

\subsection*{Tworzenie rekordu (Create)} 
Za dodawanie nowych użytkowników odpowiada procedura \texttt{crud.insert\_user}. 

\begin{itemize} 
    \item \textbf{Założenia:} Procedura przyjmuje komplet danych profilowych i dokonuje ich ostatecznej weryfikacji przed trwałym zapisem w bazie. 
    \item \textbf{Implementacja i walidacja:} Poza operacją \texttt{INSERT}, procedura aktywnie sprawdza poprawność formatu adresu e-mail przy użyciu wyrażeń regularnych (\textit{regex}). 
    \item \textbf{Obsługa błędów unikalności:} Zastosowano blok \texttt{EXCEPTION}, który przechwytuje naruszenia kluczy unikalnych (\texttt{unique\_violation}). Pozwala to na precyzyjne rozróżnienie, czy błąd rejestracji wynika z duplikatu nazwy użytkownika, czy zajętego adresu e-mail, co jest kluczowe dla komunikatów zwrotnych w interfejsie użytkownika.
\end{itemize}



\subsection*{Odczyt danych (Read)} 
Funkcja \texttt{crud.get\_all\_users} stanowi standardowy interfejs dostępu do danych dla warstwy aplikacji. 

\begin{itemize} 
    \item \textbf{Założenia:} Zapewnienie szybkiego dostępu do listy użytkowników przy zachowaniu struktury rekordowej. 
    \item \textbf{Implementacja:} Funkcja wykorzystuje mechanizm \texttt{RETURNS SETOF users}, co pozwala traktować jej wynik jak wirtualną tabelę. Zastosowanie instrukcji \texttt{RETURN QUERY} optymalizuje proces pobierania danych przez sterownik PDO w PHP. 
\end{itemize}

\subsection*{Aktualizacja danych (Update)} 
Procedura \texttt{crud.update\_user} wprowadza warstwę weryfikacji przed modyfikacją istniejących zasobów. 

\begin{itemize} 
    \item \textbf{Założenia:} Edycja danych jest dopuszczalna wyłącznie dla istniejącego w systemie identyfikatora użytkownika. 
    \item \textbf{Mechanizm walidacji:} Przed wykonaniem polecenia \texttt{UPDATE}, procedura sprawdza istnienie rekordu: 
    \begin{lstlisting}[language=SQL] 
IF NOT EXISTS (SELECT 1 FROM public.users WHERE id = p_id) THEN 
   RAISE EXCEPTION 'Nie znaleziono użytkownika o ID %', p_id; 
END IF; 
    \end{lstlisting} 
    Gwarantuje to spójność operacji i ułatwia debugowanie komunikacji na linii API-Baza danych. 
\end{itemize}

\subsection*{Usuwanie danych (Delete)} 
Procedura \texttt{crud.delete\_user} odpowiada za bezpieczne usuwanie kont przy zachowaniu integralności referencyjnej. 

\begin{itemize} 
    \item \textbf{Założenia:} Blokada usunięcia użytkowników posiadających aktywne powiązania w innych modułach systemu (np. historia treningowa). 
    \item \textbf{Obsługa wyjątków:} Wykorzystano przechwytywanie błędu \texttt{foreign\_key\_violation}: 
    \begin{lstlisting}[language=SQL] 
EXCEPTION WHEN foreign_key_violation THEN 
   RAISE EXCEPTION 'Nie można usunąć użytkownika - posiada powiązane dane...'; 
    \end{lstlisting} 
    Dzięki temu system chroni historię treningową przed powstaniem rekordów osieroconych (\textit{orphaned records}).
\end{itemize}
\newpage
%-------------------------------------------------------------------

\section{Opis pytań algorytmicznych}

Zaimplementowane procedury składowane zostały podzielone na dwie grupy w zależności od 
stopnia złożoności realizowanej logiki. Kryterium podziału stanowi charakter wykonywanych 
operacji oraz zakres przetwarzania danych.

\subsection{Algorytmy operacyjne}

Do algorytmów operacyjnych zaliczono procedury składowane realizujące podstawowe 
operacje na danych, takie jak ich pobieranie, filtrowanie oraz zapis w bazie danych. 
Algorytmy te opierają się głównie na zapytaniach typu \textit{SELECT} oraz operacjach 
\textit{INSERT} i nie wykonują złożonych obliczeń ani analizy danych.

Ich zadaniem jest zapewnienie spójnego i wydajnego dostępu do danych dla warstwy 
aplikacyjnej oraz uporządkowanie logiki dostępu do informacji przechowywanych w bazie 
danych.

\subsubsection*{get\_user\_profile\_data}

Funkcja służy do pobierania podstawowych danych profilowych użytkownika, takich jak nazwa 
użytkownika, adres e-mail oraz dane personalne. Wykorzystywana jest do prezentacji 
informacji profilowych w warstwie aplikacyjnej.

\subsubsection*{get\_user\_measurements}

Algorytm umożliwia odczyt zapisanych pomiarów biometrycznych użytkownika w kolejności 
chronologicznej. Dane te stanowią podstawę do prezentacji historii zmian parametrów 
ciała.

\subsubsection*{get\_user\_workout\_history}

Funkcja odpowiada za pobranie listy treningów przypisanych do danego użytkownika. 
Wynik wykorzystywany jest do prezentacji historii aktywności treningowej.

\subsubsection*{get\_detailed\_workout}

Algorytm umożliwia pobranie szczegółowych informacji dotyczących pojedynczej sesji 
treningowej, obejmujących ćwiczenia oraz wykonane serie. Dane te prezentowane są 
użytkownikowi w formie podsumowania treningu.

\subsubsection*{get\_exercises\_by\_muscle\_group}

Funkcja umożliwia pobranie listy ćwiczeń przypisanych do określonej partii mięśniowej. 
Algorytm wykorzystywany jest podczas tworzenia lub edycji planu treningowego.

\subsubsection*{get\_last\_exercise\_stats}

Algorytm służy do pobrania ostatnio zapisanych parametrów wykonania danego ćwiczenia, 
takich jak ciężar i liczba powtórzeń. Informacje te wykorzystywane są jako punkt 
odniesienia w kolejnych treningach.

\subsubsection*{get\_weekly\_workout\_count}

Funkcja zwraca liczbę treningów wykonanych przez użytkownika w ostatnich siedmiu dniach. 
Wynik wykorzystywany jest do prezentacji statystyk aktywności treningowej.

\subsubsection*{login\_by\_username}

Algorytm realizuje proces uwierzytelniania użytkownika na podstawie podanej nazwy 
użytkownika oraz hasła. Jego zadaniem jest weryfikacja danych dostępowych i kontrola 
dostępu do systemu.

\subsubsection*{save\_complete\_workout}

Funkcja odpowiada za zapis kompletnej sesji treningowej wraz z jej parametrami i 
strukturą ćwiczeń. Zapewnia spójność danych zapisywanych w bazie danych podczas 
rejestracji treningu.

\medskip
Ze względu na stosunkowo niski poziom złożoności algorytmów operacyjnych nie zamieszczono 
w dokumentacji szczegółowych listingów kodu ani rozbudowanych opisów ich implementacji. 
Algorytmy te realizują podstawowe operacje dostępu do danych, których logika jest 
jednoznaczna i nie wymaga dodatkowych wyjaśnień.

Pełna implementacja procedur składowanych dostępna jest w bazie danych systemu, której 
eksport został dołączony do repozytorium projektu udostępnionego na platformie GitHub. 
Takie podejście umożliwia zachowanie przejrzystości dokumentacji przy jednoczesnym 
zapewnieniu pełnej dostępności kodu źródłowego.

\newpage
\subsection{Zaawansowane algorytmy analityczne}

Do algorytmów analitycznych zaliczono procedury składowane realizujące złożone 
przetwarzanie danych treningowych i biometrycznych użytkownika. Algorytmy te 
odpowiedzialne są za wyznaczanie wartości pochodnych, analizę trendów, porównania 
historyczne oraz klasyfikację danych na podstawie określonych reguł.

W przeciwieństwie do algorytmów operacyjnych, procedury tej grupy wykorzystują 
agregacje, obliczenia matematyczne oraz logikę warunkową, a ich implementacja 
stanowi istotny element logiki systemu.

\subsubsection*{1. calculate\_exercise\_1rm}

Funkcja realizuje estymację ciężaru maksymalnego (One Repetition Maximum), jakiego użytkownik mógłby użyć w danym ćwiczeniu na podstawie najlepszej serii treningowej.

\paragraph*{Wykorzystanie w interfejsie użytkownika}
Implementację tego algorytmu widzimy w panelu progresu, gdzie wyświetlane są wyliczone wartości estymowanego 1RM dla trzech głównych bojów (wyciskanie leżąc, przysiad, martwy ciąg). Dane te pozwalają użytkownikowi monitorować wzrost siły bez konieczności każdorazowego sprawdzania realnego rekordu, co zwiększa bezpieczeństwo treningu.



\paragraph*{Implementacja algorytmu}
\begin{lstlisting}[language=SQL]
CREATE OR REPLACE FUNCTION public.calculate_exercise_1rm(
    p_user_id integer,
    p_exercise_id integer)
    RETURNS numeric
    LANGUAGE 'plpgsql'
AS $BODY$
DECLARE
    v_weight float;
    v_reps integer;
    v_1rm numeric;
BEGIN
    SELECT h.weight, h.reps 
    INTO v_weight, v_reps
    FROM (
        SELECT ws.weight, ws.reps, w.date as workout_date, ws.set_number
        FROM public.workout_sets ws
        JOIN public.workout_exercises we ON ws.workout_exercise_id = we.id
        JOIN public.workouts w ON we.workout_id = w.id
        WHERE w.user_id = p_user_id::integer 
          AND we.exercise_id = p_exercise_id::integer
    ) h
    WHERE h.set_number = 1
    ORDER BY h.workout_date DESC 
    LIMIT 1;

    IF v_weight IS NULL OR v_reps IS NULL OR v_reps = 0 THEN
        RETURN 0;
    END IF;

    IF v_reps = 1 THEN
        v_1rm := v_weight;
    ELSE
        -- Implementacja wzoru Wathena
        v_1rm := v_weight / (1.0278 - (0.0278 * v_reps));
    END IF;

    RETURN ROUND((v_1rm * 2)::numeric, 0) / 2;
END;
$BODY$;
\end{lstlisting}

\paragraph*{Opis działania algorytmu}
Algorytm działa w następujących etapach:
\begin{itemize}
    \item \textbf{Pozyskanie danych wejściowych:} System wyszukuje w bazie danych ostatnią wykonaną jednostkę treningową dla wskazanego użytkownika i konkretnego ćwiczenia.
    \item \textbf{Selekcja serii bazowej:} Algorytm pobiera parametry (ciężar i liczbę powtórzeń) z pierwszej serii (\textit{set\_number = 1}), która w metodologii treningowej zazwyczaj reprezentuje największy wysiłek siłowy.
    \item \textbf{Zastosowanie modelu matematycznego:} Na podstawie pobranych danych stosowany jest wzór Wathena. Jeśli liczba powtórzeń wynosi 1, system przyjmuje aktualny ciężar jako 1RM. W przeciwnym razie wylicza estymację według współczynnika siły.
    \item \textbf{Normalizacja wyniku:} Otrzymany wynik jest zaokrąglany do najbliższego 0,5 kg, co odpowiada standardowemu skokowi obciążenia na siłowni, czyniąc wynik praktycznym dla użytkownika.
\end{itemize}

\medskip
\subsubsection*{2. calculate\_user\_bf}

Funkcja odpowiada za estymację procentowej zawartości tkanki tłuszczowej (Body Fat Percentage) w organizmie użytkownika na podstawie pomiarów antropometrycznych.

\paragraph*{Wykorzystanie w interfejsie użytkownika}
Implementację tego algorytmu widzimy w panelu diety. Obliczona wartość pozwala użytkownikowi śledzić zmiany w kompozycji sylwetki, co jest bardziej miarodajnym wskaźnikiem progresu niż sama masa ciała, szczególnie w procesie rekompozycji lub redukcji.



\paragraph*{Implementacja algorytmu}
\begin{lstlisting}[language=SQL]
CREATE OR REPLACE FUNCTION public.calculate_user_bf(
    p_user_id integer)
    RETURNS numeric
    LANGUAGE 'plpgsql'
AS $BODY$
DECLARE
    v_gender TEXT;
    v_height NUMERIC;
    v_waist NUMERIC;
    v_neck NUMERIC;
    v_hips NUMERIC;
    v_bf NUMERIC;
BEGIN
    -- Pobranie płci użytkownika
    SELECT LOWER(TRIM(gender)) INTO v_gender FROM public.users WHERE id = p_user_id;

    -- Pobranie najnowszych pomiarów ciała
    SELECT height, waist, neck, hips INTO v_height, v_waist, v_neck, v_hips
    FROM public.body_measurements
    WHERE user_id = p_user_id
    ORDER BY date DESC LIMIT 1;

    -- Zabezpieczenie przed brakiem danych lub błędnymi wartościami
    IF v_height IS NULL OR v_waist IS NULL OR v_neck IS NULL OR (v_waist - v_neck) <= 0 THEN
        RETURN NULL;
    END IF;

    IF v_gender = 'male' THEN
        -- Wzór US Navy dla mężczyzn
        v_bf := 495 / (1.0324 - 0.19077 * log(v_waist - v_neck) + 0.15456 * log(v_height)) - 450;
    ELSE
        -- Wzór US Navy dla kobiet
        IF v_hips IS NULL OR (v_waist + v_hips - v_neck) <= 0 THEN RETURN NULL; END IF;
        v_bf := 495 / (1.29579 - 0.35004 * log(v_waist + v_hips - v_neck) + 0.22100 * log(v_height)) - 450;
    END IF;

    -- Korekta wyników skrajnych
    IF v_bf < 2 THEN RETURN 2.0; END IF;

    RETURN ROUND(v_bf::numeric, 1);
END;
$BODY$;
\end{lstlisting}

\paragraph*{Opis działania algorytmu}
Algorytm działa w następujących etapach:
\begin{itemize}
    \item \textbf{Identyfikacja profilu użytkownika:} System pobiera płeć użytkownika, ponieważ wzór matematyczny różni się istotnie dla mężczyzn i kobiet ze względu na różnice w rozmieszczeniu tkanki tłuszczowej.
    \item \textbf{Agregacja danych antropometrycznych:} Pobierane są najnowsze wprowadzone wymiary: wzrost, obwód pasa, szyi oraz (w przypadku kobiet) bioder.
    \item \textbf{Walidacja matematyczna:} Funkcja sprawdza, czy dane są kompletne oraz czy różnice obwodów są dodatnie, co zapobiega błędom krytycznym podczas obliczeń logarytmicznych.
    \item \textbf{Obliczenia według modelu US Navy:} Zastosowany zostaje oficjalny model Marynarki Wojennej USA, oparty na logarytmach dziesiętnych z proporcji obwodów do wzrostu.
    \item \textbf{Normalizacja i zaokrąglenie:} Wynik jest ograniczany do fizjologicznego minimum (2\%) i zaokrąglany do jednego miejsca po przecinku.
\end{itemize}

\newpage
\subsubsection*{3. calculate\_user\_diet\_calories}

Funkcja służy do kompleksowego wyliczania zapotrzebowania energetycznego użytkownika, uwzględniając jego parametry fizyczne, poziom aktywności oraz obrany cel sylwetkowy.
Dodatkowo funkcja ta jest wykorzystywana jest również w funkcji get\_user\_macros(p\_user\_id).

\paragraph*{Wykorzystanie w interfejsie użytkownika}
Algorytm ten jest kluczowym elementem analitycznym aplikacji, a jego wyniki prezentowane są w dwóch głównych sekcjach:
\begin{itemize}
    \item \textbf{Panel Dashboard:} Wynik wyświetlany jest w formie podsumowującej karty, informującej użytkownika o jego dziennym limicie kalorii zaraz po zalogowaniu.
    \item \textbf{Panel Dieta:} Wyliczona wartość stanowi punkt odniesienia dla dziennego spożycia makroskładników oraz jest wykorzystywana do prezentacji bilansu energetycznego.
\end{itemize}



\paragraph*{Implementacja algorytmu}
\begin{lstlisting}[language=SQL]
CREATE OR REPLACE FUNCTION public.calculate_user_diet_calories(
    p_user_id integer)
    RETURNS TABLE(recommended_calories integer, goal_label character varying, difference_from_tdee integer) 
    LANGUAGE 'plpgsql'
AS $BODY$
DECLARE
    v_gender varchar;
    v_height float;
    v_weight float;
    v_activity float;
    v_goal varchar;
    v_bmr float;
    v_tdee integer;
    v_age_const integer := 28; -- Przyjeta stala wieku
BEGIN
    -- Pobranie danych podstawowych i pomiarow
    SELECT gender INTO v_gender FROM public.users WHERE id = p_user_id;
    SELECT weight, height, activity_level, goal 
    INTO v_weight, v_height, v_activity, v_goal
    FROM public.body_measurements 
    WHERE user_id = p_user_id 
    ORDER BY date DESC LIMIT 1;

    -- Obsluga wartosci domyslnych (COALESCE)
    v_weight := COALESCE(v_weight, 70.0);
    v_height := COALESCE(v_height, 175.0);
    v_activity := COALESCE(v_activity, 1.2);
    v_goal := COALESCE(v_goal, 'Rekompozycja ciała');

    -- Obliczenie BMR wg wzoru Mifflina-St Jeora
    IF lower(v_gender) LIKE 'm%' THEN
        v_bmr := (10 * v_weight) + (6.25 * v_height) - (5 * v_age_const) + 5;
    ELSE
        v_bmr := (10 * v_weight) + (6.25 * v_height) - (5 * v_age_const) - 161;
    END IF;

    -- Wyliczenie TDEE (Total Daily Energy Expenditure)
    v_tdee := round(v_bmr * v_activity);

    -- Logika modyfikacji kalorycznosci pod wybrany cel
    IF v_goal = 'Zbudowanie masy mięśniowej' THEN
        recommended_calories := round(v_tdee * 1.10); -- Nadwyzka 10%
        goal_label := 'Masa';
    ELSIF v_goal = 'Redukcja tkanki tłuszczowej' THEN
        recommended_calories := round(v_tdee * 0.80); -- Deficyt 20%
        goal_label := 'Redukcja';
    ELSE
        recommended_calories := v_tdee;
        goal_label := 'Rekompozycja';
    END IF;

    difference_from_tdee := recommended_calories - v_tdee;
    RETURN NEXT;
END;
$BODY$;
\end{lstlisting}

\paragraph*{Opis działania algorytmu}
Algorytm działa w następujących etapach:
\begin{itemize}
    \item \textbf{Ekstrakcja danych profilowych:} Funkcja agreguje dane z tabeli użytkowników oraz najnowsze rekordy z tabeli pomiarów (\textit{body\_measurements}).
    \item \textbf{Zastosowanie mechanizmu COALESCE:} W przypadku braku wpisów antropometrycznych, system przypisuje wartości uśrednione, co zapobiega błędom w interfejsie graficznym.
    \item \textbf{Kalkulacja BMR:} Wyliczany jest wskaźnik podstawowej przemiany materii przy użyciu równania Mifflina-St Jeora, różnicowanego ze względu na płeć.
    \item \textbf{Wyznaczenie TDEE:} Wynik BMR jest mnożony przez współczynnik aktywności fizycznej (\textit{Physical Activity Level}), co daje realne zapotrzebowanie na utrzymanie wagi.
    \item \textbf{Dostosowanie do celu sylwetkowego:} W zależności od wybranego celu (Masa/Redukcja/Rekompozycja), algorytm nakłada matematyczną korektę (nadwyżkę lub deficyt procentowy) na finalny wynik kaloryczny.
\end{itemize}

\newpage
\subsubsection*{4. get\_user\_macros}

Funkcja ta odpowiada za precyzyjny podział wyliczonej puli energetycznej na poszczególne makroskładniki (białka, tłuszcze i węglowodany). Co istotne, algorytm ten nie działa w izolacji – wykorzystuje on bezpośrednio wyniki zwracane przez opisaną wcześniej funkcję \texttt{calculate\_user\_diet\_calories}, co zapewnia spójność danych w całym systemie.

\paragraph*{Wykorzystanie w interfejsie użytkownika}
Wyniki tej funkcji są kluczowe dla panelu diety, gdzie użytkownik otrzymuje konkretne wytyczne , co do makroskładników w gramach. 



\paragraph*{Implementacja algorytmu}
\begin{lstlisting}[language=SQL]
CREATE OR REPLACE FUNCTION public.get_user_macros(
    p_user_id integer)
    RETURNS TABLE(protein_g integer, fat_g integer, carbs_g integer, calories_total integer) 
    LANGUAGE 'plpgsql'
AS $BODY$
DECLARE
    v_weight float;
    v_kcal integer;
BEGIN
    -- Wywolanie zaleznosci: pobranie rekomendowanych kalorii
    SELECT recommended_calories INTO v_kcal 
    FROM public.calculate_user_diet_calories(p_user_id);

    -- Pobranie aktualnej wagi do wyliczenia podazy bialka
    SELECT weight INTO v_weight 
    FROM public.body_measurements 
    WHERE user_id = p_user_id 
    ORDER BY date DESC LIMIT 1;

    v_weight := COALESCE(v_weight, 70.0);
    calories_total := v_kcal;

    -- OBLICZENIA LOGICZNE
    -- Bialko: 2g na kg masy ciala (wg standardów ISSN)
    protein_g := round(v_weight * 2.0);
    
    -- Tluszcze: Staly udzial 25% energii (1g = 9 kcal)
    fat_g := round((v_kcal * 0.25) / 9);
    
    -- Weglowodany: Uzupelnienie pozostalej puli kcal (1g = 4 kcal)
    carbs_g := round((v_kcal - (protein_g * 4) - (fat_g * 9)) / 4);

    RETURN NEXT;
END;
$BODY$;
\end{lstlisting}

\newpage
\paragraph*{Opis działania algorytmu}
Algorytm realizuje proces dystrybucji makroskładników w następujących krokach:
\begin{itemize}
    \item \textbf{Integracja z modułem kalorii:} Funkcja wywołuje \texttt{calculate\_user\_diet\_calories}, aby uzyskać dynamicznie obliczony cel energetyczny dostosowany do aktualnego profilu użytkownika.
    \item \textbf{Priorytetyzacja białka:} W pierwszej kolejności obliczana jest podaż białka na podstawie aktualnej masy ciała ($2g/kg$), co jest kluczowe dla regeneracji mięśniowej zgodnie z literaturą przedmiotu.
    \item \textbf{Alokacja tłuszczy:} System rezerwuje 25\% całkowitego zapotrzebowania na tłuszcze, co zapewnia odpowiednią podaż energii z lipidów przy jednoczesnym zachowaniu równowagi hormonalnej.
    \item \textbf{Dopełnienie węglowodanowe:} Algorytm oblicza pozostałą liczbę kalorii (po odjęciu białek i tłuszczy) i zamienia ją na gramaturę węglowodanów. Taka kolejność gwarantuje, że suma makroskładników zawsze odpowiada założonemu limitowi kalorii.
\end{itemize}

\medskip
\subsubsection*{5. calculate\_workout\_total\_volume}

Funkcja ta odpowiada za obliczanie całkowitej objętości treningowej (\textit{Total Volume}), czyli sumarycznego tonażu przerzuconego przez użytkownika podczas pojedynczej jednostki treningowej.

\paragraph*{Wykorzystanie w interfejsie użytkownika}
Wynik tej funkcji jest wykorzystywany w panelu historia. Przy każdym archiwalnym treningu użytkownik widzi sumaryczną wartość objętości (np. w kilogramach), co pozwala na szybką ocenę intensywności danej sesji oraz porównywanie obciążeń na przestrzeni czasu bez konieczności ręcznego sumowania poszczególnych serii.



\paragraph*{Implementacja algorytmu}
\begin{lstlisting}[language=SQL]
CREATE OR REPLACE FUNCTION public.calculate_workout_total_volume(
    p_workout_id integer)
    RETURNS double precision
    LANGUAGE 'plpgsql'
AS $BODY$
DECLARE
    v_total_volume float;
BEGIN
    -- Sumujemy iloczyn ciezaru i powtorzen dla wszystkich serii w danym treningu
    SELECT SUM(ws.weight * ws.reps)
    INTO v_total_volume
    FROM public.workout_sets ws
    JOIN public.workout_exercises we ON ws.workout_exercise_id = we.id
    WHERE we.workout_id = p_workout_id;

    -- Zabezpieczenie przed zwróceniem wartosci pustej (NULL)
    RETURN COALESCE(v_total_volume, 0);
END;
$BODY$;
\end{lstlisting}

\newpage
\paragraph*{Opis działania algorytmu}
Algorytm realizuje obliczenia w następujących krokach:
\begin{itemize}
    \item \textbf{Agregacja danych serii:} Funkcja łączy tabelę serii (\textit{workout\_sets}) z tabelą ćwiczeń (\textit{workout\_exercises}), aby odfiltrować wszystkie rekordy należące do konkretnego, wskazanego identyfikatorem treningu.
    \item \textbf{Kalkulacja tonażu:} Dla każdego wiersza wykonywany jest iloczyn ciężaru (\textit{weight}) oraz liczby powtórzeń (\textit{reps}). Jest to standardowa miara objętości w treningu oporowym.
    \item \textbf{Sumowanie końcowe:} System sumuje iloczyny ze wszystkich serii i ćwiczeń wchodzących w skład danej jednostki treningowej.
    \item \textbf{Obsługa wyjątków:} Dzięki zastosowaniu funkcji \texttt{COALESCE}, w przypadku gdy trening został zarejestrowany, ale nie dodano do niego jeszcze żadnych serii, funkcja zwraca wartość 0 zamiast błędu lub wartości nieokreślonej.
\end{itemize}

\medskip
\subsubsection*{6. detect\_training\_split}

Funkcja realizuje zaawansowaną analizę wzorców treningowych użytkownika w celu automatycznej identyfikacji stosowanego systemu (splitu) treningowego na podstawie historii aktywności z ostatnich 30 dni.

\paragraph*{Wykorzystanie w interfejsie użytkownika}
Algorytm ten znajduje zastosowanie w dwóch kluczowych obszarach aplikacji:
\begin{itemize}
    \item \textbf{Panel Dashboard:} Wynik wyświetlany jest w jednej z kart podsumowujących, dając użytkownikowi natychmiastowy feedback na temat charakteru jego aktualnego planu.
    \item \textbf{Panel Progresu:} Informacja o typie splitu służy jako kontekst do analizy wzrostu siły i objętości, pomagając zrozumieć, czy dany system treningu przynosi oczekiwane rezultaty.
\end{itemize}



\paragraph*{Implementacja algorytmu}
\begin{lstlisting}[language=SQL]
CREATE OR REPLACE FUNCTION public.detect_training_split(
    p_user_id integer)
    RETURNS text
    LANGUAGE 'plpgsql'
AS $BODY$
DECLARE
    v_avg_groups_per_workout FLOAT;
    v_days_active_30d INT;
    v_has_legs BOOLEAN := FALSE;
    v_has_push BOOLEAN := FALSE;
    v_has_pull BOOLEAN := FALSE;
    v_result TEXT;
BEGIN
    -- Agregacja danych o trenowanych grupach miesniowych
    SELECT 
        COUNT(DISTINCT s.workout_id),
        EXISTS (SELECT 1 FROM crud.get_user_training_stats(p_user_id) x 
                WHERE x.muscle_group_name ILIKE ANY (ARRAY['%Nogi%', '%Uda%', '%Lydki%', '%Posladki%'])),
        EXISTS (SELECT 1 FROM crud.get_user_training_stats(p_user_id) x 
                WHERE x.muscle_group_name IN ('Klatka piersiowa', 'Barki', 'Triceps')),
        EXISTS (SELECT 1 FROM crud.get_user_training_stats(p_user_id) x 
                WHERE x.muscle_group_name IN ('Plecy', 'Biceps'))
    INTO v_days_active_30d, v_has_legs, v_has_push, v_has_pull
    FROM crud.get_user_training_stats(p_user_id) s;

    -- Obliczenie sredniej liczby grup na jednostke treningowa
    SELECT AVG(daily_count) INTO v_avg_groups_per_workout
    FROM (
        SELECT COUNT(DISTINCT muscle_group_name) as daily_count
        FROM crud.get_user_training_stats(p_user_id)
        GROUP BY workout_id
    ) AS subquery;

    IF v_days_active_30d = 0 OR v_avg_groups_per_workout IS NULL THEN
        RETURN 'Brak aktywności (30 dni)';
    END IF;

    -- Logika klasyfikacji systemu treningowego
    IF v_avg_groups_per_workout >= 4.0 THEN
        v_result := 'Full Body Workout';
    ELSIF v_has_push AND v_has_pull AND v_has_legs THEN
        v_result := 'Push Pull Legs';
    ELSIF v_has_push AND v_has_pull AND NOT v_has_legs THEN
        v_result := 'Push Pull (No Legs)';
    ELSIF v_has_legs AND v_days_active_30d >= 4 THEN
        v_result := 'Upper Lower';
    ELSE
        v_result := 'Własny system';
    END IF;

    RETURN v_result;
END;
$BODY$;
\end{lstlisting}

\paragraph*{Opis działania algorytmu}
Algorytm klasyfikuje system treningowy w oparciu o następujące kroki:
\begin{itemize}
    \item \textbf{Ekstrakcja statystyk mięśniowych:} Funkcja analizuje dane z pomocniczej procedury \texttt{get\_user\_training\_stats}, sprawdzając obecność kluczowych ruchów: wypychających (\textit{Push}), przyciągających (\textit{Pull}) oraz angażujących dolne partie ciała.
    \item \textbf{Analiza wszechstronności sesji:} Obliczana jest średnia liczba unikalnych grup mięśniowych trenowanych podczas jednej wizyty na siłowni.
    \item \textbf{Kategoryzacja logiczna:} 
    \begin{itemize}
        \item Jeżeli średnia liczba grup na trening wynosi $\ge 4$, system rozpoznaje \textbf{FBW (Full Body Workout)}.
        \item Jeżeli użytkownik wykonuje ruchy Push, Pull oraz nogi w różnych sesjach, rozpoznawany jest system \textbf{PPL (Push Pull Legs)}.
        \item Przy braku treningu nóg, ale obecności ruchów Push i Pull, system zwraca informację o niepełnym splicie.
        \item Wysoka częstotliwość (4+ dni) przy obecności treningu nóg sugeruje system \textbf{Upper/Lower}.
    \end{itemize}
    \item \textbf{Obsługa braku danych:} Algorytm poprawnie identyfikuje okresy roztrenowania lub braku aktywności w zdefiniowanym oknie czasowym.
\end{itemize}

\subsubsection*{7. get\_exercise\_progression\_status}

Funkcja ta służy do dynamicznej analizy porównawczej objętości konkretnego ćwiczenia pomiędzy dwiema ostatnimi jednostkami treningowymi, w których dane ćwiczenie wystąpiło.

\paragraph*{Wykorzystanie w interfejsie użytkownika}
Algorytm ten jest wykorzystywany w momencie, gdy użytkownik dodaje nową sesję treningową. W momencie, gdy użytkownik wybiera konkretne ćwiczenie z listy, system natychmiast wyświetla podpowiedź.. Informuje ona, czy na ostatniej sesji nastąpił progres, stagnacja, czy regresja w stosunku do poprzedniego razu. Pozwala to użytkownikowi na bieżąco korygować obciążenie, aby zachować zasadę progresywnego przeładowania (\textit{progressive overload}).



\paragraph*{Implementacja algorytmu}
\begin{lstlisting}[language=SQL]
CREATE OR REPLACE FUNCTION public.get_exercise_progression_status(
    p_user_id integer,
    p_exercise_id integer)
    RETURNS text
    LANGUAGE 'plpgsql'
AS $BODY$
DECLARE
    v_last_total_vol float;
    v_prev_total_vol float;
    v_entry_count integer;
BEGIN
    -- Pobranie objetosci z dwóch ostatnich sesji treningowych
    WITH exercise_history AS (
        SELECT 
            w.id as workout_id,
            w.date,
            SUM(ws.weight * ws.reps) as total_volume
        FROM public.workout_sets ws
        JOIN public.workout_exercises we ON ws.workout_exercise_id = we.id
        JOIN public.workouts w ON we.workout_id = w.id
        WHERE w.user_id = p_user_id 
          AND we.exercise_id = p_exercise_id
        GROUP BY w.id, w.date
        ORDER BY w.date DESC
        LIMIT 2
    ),
    ranked_history AS (
        SELECT 
            total_volume, 
            ROW_NUMBER() OVER (ORDER BY date DESC) as rn
        FROM exercise_history
    )
    SELECT 
        MAX(CASE WHEN rn = 1 THEN total_volume END),
        MAX(CASE WHEN rn = 2 THEN total_volume END),
        (SELECT COUNT(*) FROM exercise_history)
    INTO v_last_total_vol, v_prev_total_vol, v_entry_count
    FROM ranked_history;

    -- Klasyfikacja statusu na podstawie historii
    IF v_entry_count < 2 THEN 
        RETURN 'NEW'; 
    END IF;

    IF v_last_total_vol > v_prev_total_vol THEN
        RETURN 'PROGRESS';     
    ELSIF v_last_total_vol = v_prev_total_vol THEN
        RETURN 'STAGNATION';   
    ELSE
        RETURN 'REGRESSION';   
    END IF;
END;
$BODY$;
\end{lstlisting}

\paragraph*{Opis działania algorytmu}
Algorytm realizuje analizę porównawczą w następujących etapach:
\begin{itemize}
    \item \textbf{Agregacja historii ćwiczenia:} Wykorzystując wspólne wyrażenia tablicowe (\textit{Common Table Expressions - CTE}), system selekcjonuje dwa najświeższe treningi użytkownika, w których brało udział dane ćwiczenie, obliczając dla nich sumaryczną objętość (\textit{weight * reps}).
    \item \textbf{Rankowanie rekordów:} Funkcja okna \texttt{ROW\_NUMBER()} przypisuje indeksy (1 i 2) do sesji, co pozwala na precyzyjne odróżnienie ostatniego treningu od przedostatniego.
    \item \textbf{Weryfikacja stażu:} Jeżeli w historii znajduje się tylko jedna sesja (lub zero), algorytm zwraca status \texttt{NEW}, co informuje interfejs o braku bazy do porównania.
    \item \textbf{Komparacja wyników:} System porównuje tonaż sesji $n$ z sesją $n-1$:
    \begin{itemize}
        \item \texttt{PROGRESS} – gdy objętość wzrosła,
        \item \texttt{STAGNATION} – gdy tonaż pozostał identyczny,
        \item \texttt{REGRESSION} – gdy odnotowano spadek obciążenia lub liczby powtórzeń.
    \end{itemize}
\end{itemize}

\newpage
\subsubsection*{8. get\_exercise\_volume\_progression}

Funkcja ta agreguje dane historyczne dotyczące tonażu konkretnego ćwiczenia w czasie, umożliwiając śledzenie długofalowej progresji siłowej użytkownika.

\paragraph*{Wykorzystanie w interfejsie użytkownika}
Wyniki tej funkcji są wykorzystywane do generowania interaktywnego wykresu liniowego w panelu Dashboard. Dzięki danym zwracanym w formie tabelarycznej (data i suma objętości), aplikacja kliencka może w sposób czytelny zaprezentować użytkownikowi trend wzrostowy, co jest kluczowe dla utrzymania motywacji oraz weryfikacji skuteczności planu treningowego.



\paragraph*{Implementacja algorytmu}
\begin{lstlisting}[language=SQL]
CREATE OR REPLACE FUNCTION public.get_exercise_volume_progression(
    p_user_id integer,
    p_exercise_id integer)
    RETURNS TABLE(workout_date date, total_volume numeric) 
    LANGUAGE 'plpgsql'
AS $BODY$
BEGIN
    RETURN QUERY
    SELECT 
        w.date::DATE,
        -- Obliczenie objetosci suma (ciezar * powtorzenia)
        SUM(COALESCE(ws.weight, 0) * COALESCE(ws.reps, 0))::NUMERIC
    FROM public.workouts w
    JOIN public.workout_exercises we ON w.id = we.workout_id
    JOIN public.workout_sets ws ON we.id = ws.workout_exercise_id
    WHERE w.user_id = p_user_id 
      AND we.exercise_id = p_exercise_id
      AND w.date >= CURRENT_DATE - INTERVAL '3 months'
    GROUP BY w.date::DATE
    ORDER BY w.date::DATE ASC;
END;
$BODY$;
\end{lstlisting}

\paragraph*{Opis działania algorytmu}
Algorytm realizuje proces przygotowania danych pod wykresy w następujących etapach:
\begin{itemize}
    \item \textbf{Wielopoziomowe łączenie danych:} Funkcja dokonuje złączenia (\textit{JOIN}) trzech kluczowych tabel: nagłówków treningów (\textit{workouts}), przypisanych do nich ćwiczeń (\textit{workout\_exercises}) oraz szczegółowych serii (\textit{workout\_sets}).
    \item \textbf{Filtrowanie czasowe:} System ogranicza analizę do ostatnich 3 miesięcy (\textit{INTERVAL '3 months'}). Jest to zabieg optymalizacyjny, który zapewnia czytelność wykresu oraz szybkość odpowiedzi bazy danych, skupiając się na aktualnej formie użytkownika.
    \item \textbf{Agregacja matematyczna:} Dla każdej unikalnej daty treningowej obliczana jest suma iloczynów obciążenia i liczby powtórzeń. Zastosowanie \texttt{COALESCE} gwarantuje, że ewentualne puste rekordy nie przerwą procesu sumowania i zostaną potraktowane jako wartość 0.
    \item \textbf{Sortowanie chronologiczne:} Zwracany zestaw danych jest uporządkowany narastająco według daty, co jest niezbędne do poprawnego wyrenderowania osi X na wykresie liniowym przez bibliotekę Chart.js
\end{itemize}

\newpage
\subsubsection*{9. get\_user\_muscle\_balance}

Funkcja realizuje analizę dystrybucji obciążenia treningowego na poszczególne partie mięśniowe w ujęciu procentowym, pozwalając na identyfikację priorytetów lub zaniedbań w planie treningowym.

\paragraph*{Wykorzystanie w interfejsie użytkownika}
Algorytm ten jest wykorzystywany w panelu progresji, gdzie w dedykowanej karcie użytkownik widzi wykres przedstawiający sposób angażowania partii mięśniowych w ciągu ostatnich 7 dni. Dzięki temu system może pełnić rolę doradczą, sugerując użytkownikowi, czy zachowuje on odpowiedni balans między grupami takimi jak klatka piersiowa a plecy czy nogi. Pozwala też wyświetlać komunikat w przypadku, gdy któraś partia nie dostała żadnej stymulacji.



\paragraph*{Implementacja algorytmu}
\begin{lstlisting}[language=SQL]
CREATE OR REPLACE FUNCTION public.get_user_muscle_balance(
    p_user_id integer)
    RETURNS TABLE(muscle_group_name text, volume_percentage numeric) 
    LANGUAGE 'plpgsql'
AS $BODY$
DECLARE
    v_total_volume numeric;
BEGIN
    -- Obliczenie calkowitej objetosci z ostatnich 7 dni
    SELECT SUM(ws.weight * ws.reps)::numeric INTO v_total_volume
    FROM public.workout_sets ws
    JOIN public.workout_exercises we ON ws.workout_exercise_id = we.id
    JOIN public.workouts w ON we.workout_id = w.id
    WHERE w.user_id = p_user_id::integer 
      AND w.date > NOW() - INTERVAL '7 days';

    -- Zabezpieczenie przed dzieleniem przez zero
    IF v_total_volume IS NULL OR v_total_volume = 0 THEN
        RETURN;
    END IF;

    -- Obliczenie procentowego udzialu kazdej grupy miesniowej
    RETURN QUERY
    SELECT 
        mg.name::text,
        ROUND(((SUM(ws.weight * ws.reps) / v_total_volume) * 100)::numeric, 1) as percentage
    FROM public.workout_sets ws
    JOIN public.workout_exercises we ON ws.workout_exercise_id = we.id
    JOIN public.workouts w ON we.workout_id = w.id
    JOIN public.exercises e ON we.exercise_id = e.id
    JOIN crud.get_all_muscle_groups() mg ON e.muscle_group_id = mg.id
    WHERE w.user_id = p_user_id::integer 
      AND w.date > NOW() - INTERVAL '7 days'
    GROUP BY mg.name
    ORDER BY percentage DESC;
END;
$BODY$;
\end{lstlisting}
\newpage
\paragraph*{Opis działania algorytmu}
Algorytm realizuje proces analizy balansu mięśniowego w następujących etapach:
\begin{itemize}
    \item \textbf{Wyznaczenie bazy odniesienia:} W pierwszym kroku funkcja oblicza sumaryczny tonaż (\textit{Total Volume}) ze wszystkich treningów użytkownika z ostatniego tygodnia. Stanowi on 100\% wkładu treningowego.
    \item \textbf{Weryfikacja aktywności:} System sprawdza, czy w danym okresie wystąpiła jakakolwiek aktywność. W przypadku braku danych wejściowych, funkcja kończy działanie bez zwracania wyników, co zapobiega błędom dzielenia przez zero.
    \item \textbf{Mapowanie ćwiczeń na grupy mięśniowe:} Algorytm dokonuje złożonego złączenia pięciu tabel, przechodząc od pojedynczych serii, przez ćwiczenia, aż do słownika grup mięśniowych (\textit{muscle\_groups}).
    \item \textbf{Kalkulacja relatywna:} Dla każdej unikalnej grupy mięśniowej obliczana jest suma objętości, która następnie jest dzielona przez całkowity tonaż tygodniowy.
    \item \textbf{Formatowanie danych:} Wyniki są zaokrąglane do jednego miejsca po przecinku i sortowane malejąco, co pozwala frontendowi na natychmiastowe wyświetlenie najbardziej dominujących partii mięśniowych w planie użytkownika.
\end{itemize}

\newpage
\subsubsection*{10. get\_volume\_comparison}

Funkcja ta odpowiada za zestawienie całkowitej objętości treningowej z bieżącego tygodnia z analogicznym okresem poprzedzającym, co pozwala na błyskawiczną ocenę tendencji progresu.

\paragraph*{Wykorzystanie w interfejsie użytkownika}
Wyniki tej funkcji są prezentowane w panelach \textit{Dashboard} oraz \textit{Progress} w formie wskaźników trendu (np. procentowy wzrost lub spadek tonażu). Pozwala to użytkownikowi na szybką weryfikację, czy zachowuje on założoną intensywność treningową w skali mikrocyklu, co jest kluczowe dla uniknięcia przetrenowania lub stagnacji.



\paragraph*{Implementacja algorytmu}
\begin{lstlisting}[language=SQL]
CREATE OR REPLACE FUNCTION public.get_volume_comparison(
    p_user_id integer)
    RETURNS TABLE(current_volume numeric, previous_volume numeric) 
    LANGUAGE 'plpgsql'
AS $BODY$
BEGIN
    RETURN QUERY
    SELECT 
        -- Tonaz z biezacego tygodnia (0-7 dni temu)
        COALESCE((
            SELECT SUM(ws.weight * ws.reps)::numeric 
            FROM crud.get_all_workout_sets() ws
            JOIN crud.get_all_workout_exercises() we ON ws.workout_exercise_id = we.id
            JOIN crud.get_all_workouts() w ON we.workout_id = w.id
            WHERE w.user_id = p_user_id::integer 
              AND w.date > NOW() - INTERVAL '7 days'
        ), 0),
        
        -- Tonaz z ubieglego tygodnia (8-14 dni temu)
        COALESCE((
            SELECT SUM(ws.weight * ws.reps)::numeric 
            FROM crud.get_all_workout_sets() ws
            JOIN crud.get_all_workout_exercises() we ON ws.workout_exercise_id = we.id
            JOIN crud.get_all_workouts() w ON we.workout_id = w.id
            WHERE w.user_id = p_user_id::integer 
              AND w.date <= NOW() - INTERVAL '7 days' 
              AND w.date > NOW() - INTERVAL '14 days'
        ), 0);
END;
$BODY$;
\end{lstlisting}

\paragraph*{Opis działania algorytmu}
Algorytm porównuje aktywność fizyczną w dwóch oknach czasowych w następujący sposób:
\begin{itemize}
    \item \textbf{Selekcja bieżącego okresu:} System oblicza sumaryczny tonaż wszystkich serii wykonanych przez użytkownika w ciągu ostatnich 7 dni od momentu zapytania.
    \item \textbf{Selekcja okresu referencyjnego:} W drugim kroku funkcja izoluje dane z przedziału między 8. a 14. dniem wstecz, co stanowi bazę porównawczą dla bieżącego tygodnia.
    \item \textbf{Wykorzystanie widoków/procedur CRUD:} Funkcja korzysta z abstrakcji \texttt{get\_all\_...}, co zapewnia, że analiza zawsze operuje na spójnym zestawie danych, niezależnie od ewentualnych zmian w strukturze tabel podstawowych.
    \item \textbf{Zapewnienie ciągłości danych:} Dzięki zastosowaniu \texttt{COALESCE}, nawet w przypadku braku treningów w jednym z analizowanych okresów, funkcja zwraca wartość 0. Zapobiega to błędom w interfejsie graficznym i pozwala na poprawne obliczenie delty progresu przez aplikację kliencką.
\end{itemize}


\subsection*{Katalog algorytmów zaawansowanych}

\begin{itemize} \item \textbf{calculate\_exercise\_1rm(p\_user\_id, p\_exercise\_id)} \ \textit{Dlaczego zaawansowany:} Dokonuje matematycznej estymacji wartości pochodnej (siły maksymalnej) na podstawie analizy historycznych serii treningowych przy użyciu wzoru Wathena.

\item \textbf{calculate\_user\_bf(p\_user\_id)} \\
\textit{Dlaczego zaawansowany:} Implementuje model logarytmiczny US Navy, przetwarzając dane antropometryczne w celu wyznaczenia składu ciała użytkownika.

\item \textbf{calculate\_user\_diet\_calories(p\_user\_id)} \\
\textit{Dlaczego zaawansowany:} Wykorzystuje dietetyczne wzory prognostyczne (Mifflin-St Jeor) do wyznaczania BMR i TDEE, dynamicznie dostosowując wynik do parametrów fizycznych i celów użytkownika.

\item \textbf{calculate\_workout\_total\_volume(p\_workout\_id)} \\
\textit{Dlaczego zaawansowany:} Przetwarza wielopoziomowe struktury danych (JOIN-y między treningami a seriami), wykonując agregację matematyczną tonażu treningowego.

\item \textbf{detect\_training\_split(p\_user\_id)} \\
\textit{Dlaczego zaawansowany:} Wykorzystuje heurystykę i logikę warunkową do automatycznego rozpoznawania wzorców behawioralnych użytkownika i kategoryzacji jego systemu treningowego.

\item \textbf{get\_exercise\_progression\_status(p\_user\_id, p\_exercise\_id)} \\
\textit{Dlaczego zaawansowany:} Stosuje analizę porównawczą (trendów) na danych historycznych, interpretując kierunek zmian (progres/stagnacja/regres) w wydolności siłowej.

\item \textbf{get\_exercise\_volume\_progression(p\_user\_id, p\_exercise\_id)} \\
\textit{Dlaczego zaawansowany:} Agreguje dane w oknie czasowym i analizuje dynamikę zmian objętości, przygotowując zestawy danych pod wizualizację trendów.

\item \textbf{get\_user\_macros(p\_user\_id)} \\
\textit{Dlaczego zaawansowany:} Wylicza proporcje makroskładników poprzez integrację z algorytmem kaloryczności, stosując reguły priorytetyzacji składników odżywczych.

\item \textbf{get\_user\_muscle\_balance(p\_user\_id)} \\
\textit{Dlaczego zaawansowany:} Dokonuje analizy rozkładu obciążenia na struktury anatomiczne, przeliczając udziały procentowe zaangażowania poszczególnych partii mięśniowych.

\item \textbf{get\_volume\_comparison(p\_user\_id)} \\
\textit{Dlaczego zaawansowany:} Wykonuje zestawienie zagregowanej objętości treningowej w dwóch odrębnych interwałach czasowych, umożliwiając analizę trendów tydzień do tygodnia.
\end{itemize}
\newpage
\paragraph*{Wnioski projektowe} Przeniesienie powyższej logiki bezpośrednio do warstwy bazy danych (PL/pgSQL) pozwoliło na: \begin{enumerate} \item \textbf{Zwiększenie wydajności:} Redukcję ilości przesyłanych danych między serwerem bazy danych a aplikacją (przesyłane są tylko gotowe wyniki obliczeń). \item \textbf{Centralizację logiki:} Zapewnienie identycznych wyników obliczeń niezależnie od tego, czy zapytanie pochodzi z panelu webowego, czy mobilnego. \item \textbf{Spójność danych:} Gwarancję, że skomplikowane wzory matematyczne są wykonywane zawsze na najbardziej aktualnych danych wewnątrz transakcji. \end{enumerate}